/**
 * OpenAI Realtime Service - Simplified Version
 *
 * A simple, bulletproof service for OpenAI Realtime API with WebRTC.
 * Focuses on simplicity and reliability over complex abstractions.
 */
import type { RealtimeVoice, AudioFormat } from '../types';
type Modality = 'text' | 'audio';
type ToolChoice = 'auto' | 'none' | 'required' | {
    type: 'function';
    function: {
        name: string;
    };
};
interface TurnDetection {
    type: 'server_vad';
    threshold?: number;
    prefix_padding_ms?: number;
    silence_duration_ms?: number;
}
interface Tool {
    type: 'function';
    function: {
        name: string;
        description?: string;
        parameters?: any;
    };
}
interface InputAudioTranscription {
    model?: string;
}
/**
 * Single unified configuration interface
 */
export interface RealtimeServiceConfig {
    /** Token endpoint URL for authentication */
    tokenEndpoint: string;
    /** Model to use (default: gpt-4o-realtime-preview) */
    model?: string;
    /** Instructions for the model */
    instructions?: string;
    /** Voice for audio responses (default: alloy) */
    voice?: RealtimeVoice;
    /** Modalities to enable (default: ['text', 'audio']) */
    modalities?: Modality[];
    /** Temperature for responses (default: 0.8) */
    temperature?: number;
    /** Max output tokens (default: 4096) */
    maxOutputTokens?: number | 'inf';
    /** Input audio format (default: pcm16) */
    inputAudioFormat?: AudioFormat;
    /** Output audio format (default: pcm16) */
    outputAudioFormat?: AudioFormat;
    /** Enable input transcription */
    inputAudioTranscription?: InputAudioTranscription;
    /** Turn detection settings */
    turnDetection?: TurnDetection;
    /** Available tools */
    tools?: Tool[];
    /** Tool choice strategy */
    toolChoice?: ToolChoice;
    /** ICE servers for WebRTC */
    iceServers?: RTCIceServer[];
    /** Audio constraints */
    audioConstraints?: MediaTrackConstraints;
    /** Enable debug logging */
    debug?: boolean;
    /** Auto-reconnect on disconnect (default: true) */
    autoReconnect?: boolean;
    /** Max reconnect attempts (default: 3) */
    maxReconnectAttempts?: number;
}
/**
 * Simplified service state
 */
export interface RealtimeServiceState {
    /** Connection status */
    status: 'disconnected' | 'connecting' | 'connected' | 'error';
    /** Current session ID */
    sessionId: string | null;
    /** Last error */
    error: Error | null;
    /** Basic metrics */
    metrics: {
        connectedAt: Date | null;
        messagesSent: number;
        messagesReceived: number;
    };
}
/**
 * Essential service events
 */
export interface RealtimeServiceEvents {
    /** Connected and ready */
    ready: () => void;
    /** Disconnected */
    disconnected: (reason?: string) => void;
    /** Error occurred */
    error: (error: Error) => void;
    /** State changed */
    stateChanged: (state: RealtimeServiceState) => void;
    /** Audio track received (for playback) */
    audioTrackReceived: (track: MediaStreamTrack) => void;
    /** Text received */
    textReceived: (text: string) => void;
    /** Function call requested */
    functionCall: (name: string, args: any, callId: string) => void;
    /** Conversation updated */
    conversationUpdated: (items: any[]) => void;
}
/**
 * Simplified OpenAI Realtime Service
 *
 * Simple API:
 * - new OpenAIRealtimeService(config)
 * - await service.connect()
 * - service.sendText(text)
 * - service.on('textReceived', handler)
 */
export declare class OpenAIRealtimeService {
    private webrtcManager;
    private config;
    private state;
    private eventListeners;
    private reconnectAttempts;
    private reconnectTimer;
    private isDisposed;
    /**
     * Create a new service instance
     */
    constructor(config: RealtimeServiceConfig);
    /**
     * Connect to OpenAI Realtime API
     */
    connect(): Promise<void>;
    /**
     * Disconnect from the service
     */
    disconnect(): Promise<void>;
    /**
     * Send text message
     */
    sendText(text: string): void;
    /**
     * Update configuration
     */
    updateConfig(updates: Partial<RealtimeServiceConfig>): void;
    /**
     * Get current state
     */
    getState(): Readonly<RealtimeServiceState>;
    /**
     * Check if connected
     */
    isConnected(): boolean;
    /**
     * Add event listener
     */
    on<K extends keyof RealtimeServiceEvents>(event: K, listener: RealtimeServiceEvents[K]): void;
    /**
     * Remove event listener
     */
    off<K extends keyof RealtimeServiceEvents>(event: K, listener: RealtimeServiceEvents[K]): void;
    /**
     * Dispose of the service
     */
    dispose(): void;
    private setupEventHandlers;
    private handleOpenAIMessage;
    private waitForDataChannel;
    private sendConfiguration;
    private handleDisconnect;
    private scheduleReconnect;
    private updateState;
    private emit;
    private log;
}
export default OpenAIRealtimeService;
//# sourceMappingURL=OpenAIRealtimeService.d.ts.map