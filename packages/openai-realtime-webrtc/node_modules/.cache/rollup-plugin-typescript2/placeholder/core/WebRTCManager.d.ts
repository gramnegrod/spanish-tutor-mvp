/**
 * WebRTCManager for OpenAI Realtime API
 *
 * Manages WebRTC peer connections, media streams, and real-time communication
 * with the OpenAI Realtime API endpoints.
 */
export interface WebRTCConfig {
    /** Token endpoint URL for ephemeral authentication */
    tokenEndpoint?: string;
    /** OpenAI model to use */
    model?: string;
    /** ICE servers configuration */
    iceServers?: RTCIceServer[];
    /** ICE transport policy */
    iceTransportPolicy?: RTCIceTransportPolicy;
    /** Bundle policy for WebRTC */
    bundlePolicy?: RTCBundlePolicy;
    /** Additional RTC configuration options */
    rtcConfiguration?: Partial<RTCConfiguration>;
    /** Audio constraints for media capture */
    audioConstraints?: MediaTrackConstraints;
    /** Enable echo cancellation */
    echoCancellation?: boolean;
    /** Enable noise suppression */
    noiseSuppression?: boolean;
    /** Enable auto gain control */
    autoGainControl?: boolean;
    /** Audio sample rate (Hz) */
    sampleRate?: number;
    /** Number of audio channels */
    channelCount?: number;
    /** Audio buffer size */
    bufferSize?: number;
    /** Connection timeout in milliseconds */
    connectionTimeout?: number;
    /** Keep-alive interval in milliseconds */
    keepAliveInterval?: number;
}
export interface ConnectionState {
    /** WebRTC connection state */
    connectionState: RTCPeerConnectionState;
    /** ICE connection state */
    iceConnectionState: RTCIceConnectionState;
    /** ICE gathering state */
    iceGatheringState: RTCIceGatheringState;
    /** Data channel state */
    dataChannelState: RTCDataChannelState | null;
    /** Is audio streaming active */
    isAudioStreaming: boolean;
    /** Local media stream */
    localStream: MediaStream | null;
    /** Remote media stream */
    remoteStream: MediaStream | null;
}
export interface WebRTCEvents {
    /** Connection established */
    connected: () => void;
    /** Connection closed */
    disconnected: (reason?: string) => void;
    /** Connection failed */
    connectionFailed: (error: Error) => void;
    /** ICE candidate found */
    iceCandidate: (candidate: RTCIceCandidate) => void;
    /** Data channel message received */
    dataChannelMessage: (data: any) => void;
    /** Audio track received */
    audioTrackReceived: (track: MediaStreamTrack) => void;
    /** Audio data available */
    audioData: (data: ArrayBuffer) => void;
    /** Connection state changed */
    connectionStateChanged: (state: ConnectionState) => void;
}
/**
 * Manages WebRTC connections for OpenAI Realtime API
 */
export declare class WebRTCManager {
    private peerConnection;
    private dataChannel;
    private localStream;
    private remoteStream;
    private config;
    private connectionState;
    private eventListeners;
    private isDisposed;
    private ephemeralToken;
    constructor(config?: WebRTCConfig);
    /**
     * Initialize WebRTC connection
     */
    initialize(): Promise<void>;
    /**
     * Create WebRTC offer
     */
    createOffer(): Promise<RTCSessionDescriptionInit>;
    /**
     * Handle WebRTC answer
     */
    handleAnswer(answer: RTCSessionDescriptionInit): Promise<void>;
    /**
     * Add ICE candidate
     */
    addIceCandidate(candidate: RTCIceCandidateInit): Promise<void>;
    /**
     * Send data through data channel
     */
    sendData(data: string | ArrayBuffer | Blob): void;
    /**
     * Start audio streaming
     */
    startAudioStreaming(): Promise<void>;
    /**
     * Stop audio streaming
     */
    stopAudioStreaming(): void;
    /**
     * Get current connection state
     */
    getConnectionState(): Readonly<ConnectionState>;
    /**
     * Check if WebRTC is connected
     */
    isConnected(): boolean;
    /**
     * Add event listener
     */
    on<K extends keyof WebRTCEvents>(event: K, listener: WebRTCEvents[K]): void;
    /**
     * Remove event listener
     */
    off<K extends keyof WebRTCEvents>(event: K, listener: WebRTCEvents[K]): void;
    /**
     * Close WebRTC connection and cleanup
     */
    close(reason?: string): Promise<void>;
    /**
     * Dispose of the WebRTC manager
     */
    dispose(): void;
    /**
     * Get ephemeral token from endpoint
     */
    private getEphemeralToken;
    /**
     * Send offer to OpenAI and handle response
     */
    private sendOfferToOpenAI;
    /**
     * Complete WebRTC negotiation with OpenAI
     */
    completeNegotiation(): Promise<void>;
    private setupPeerConnectionHandlers;
    private setupDataChannelHandlers;
    private setupLocalMedia;
    private updateConnectionState;
    private emit;
    private cleanup;
}
export default WebRTCManager;
//# sourceMappingURL=WebRTCManager.d.ts.map