/**
 * OpenAI Realtime WebRTC Configuration Types
 *
 * Configuration interfaces and types for session management,
 * WebRTC connections, and audio processing.
 */
import type { RealtimeModel, RealtimeVoice, AudioFormat, TurnDetection, Tool, ToolChoice, Modality, InputAudioTranscription } from './index';
export interface SessionConfig {
    /** OpenAI API key for authentication */
    apiKey: string;
    /** Model to use for the session */
    model?: RealtimeModel;
    /** Instructions for the model behavior */
    instructions?: string;
    /** Voice to use for audio responses */
    voice?: RealtimeVoice;
    /** Input audio format */
    inputAudioFormat?: AudioFormat;
    /** Output audio format */
    outputAudioFormat?: AudioFormat;
    /** Input audio transcription settings */
    inputAudioTranscription?: InputAudioTranscription;
    /** Turn detection configuration */
    turnDetection?: TurnDetection;
    /** Available tools for the model */
    tools?: Tool[];
    /** Tool choice strategy */
    toolChoice?: ToolChoice;
    /** Response generation temperature (0-2) */
    temperature?: number;
    /** Maximum response output tokens */
    maxResponseOutputTokens?: number | 'inf';
    /** Enabled modalities */
    modalities?: Modality[];
}
export interface WebRTCConfig {
    /** ICE servers configuration */
    iceServers?: RTCIceServer[];
    /** ICE transport policy */
    iceTransportPolicy?: RTCIceTransportPolicy;
    /** Bundle policy for WebRTC */
    bundlePolicy?: RTCBundlePolicy;
    /** Additional RTC configuration options */
    rtcConfiguration?: Partial<RTCConfiguration>;
    /** Audio constraints for media capture */
    audioConstraints?: MediaTrackConstraints;
    /** Enable echo cancellation */
    echoCancellation?: boolean;
    /** Enable noise suppression */
    noiseSuppression?: boolean;
    /** Enable auto gain control */
    autoGainControl?: boolean;
    /** Audio sample rate (Hz) */
    sampleRate?: number;
    /** Number of audio channels */
    channelCount?: number;
    /** Audio buffer size */
    bufferSize?: number;
    /** Connection timeout in milliseconds */
    connectionTimeout?: number;
    /** Keep-alive interval in milliseconds */
    keepAliveInterval?: number;
    /** Token endpoint URL for ephemeral authentication */
    tokenEndpoint?: string;
    /** OpenAI model to use for the session */
    model?: string;
}
export interface AudioConfig {
    /** Audio format for input */
    inputFormat: AudioFormat;
    /** Audio format for output */
    outputFormat: AudioFormat;
    /** Sample rate for audio processing */
    sampleRate: number;
    /** Number of audio channels */
    channels: number;
    /** Audio buffer size in samples */
    bufferSize: number;
    /** Maximum audio buffer size in bytes */
    maxBufferSize: number;
    /** Enable real-time audio processing */
    realTimeProcessing: boolean;
    /** Audio quality settings */
    quality: AudioQualityConfig;
    /** Audio encoding settings */
    encoding: AudioEncodingConfig;
}
export interface AudioQualityConfig {
    /** Enable echo cancellation */
    echoCancellation: boolean;
    /** Enable noise suppression */
    noiseSuppression: boolean;
    /** Enable auto gain control */
    autoGainControl: boolean;
    /** Audio bit rate */
    bitRate?: number;
    /** Audio compression level */
    compressionLevel?: number;
}
export interface AudioEncodingConfig {
    /** Audio codec to use */
    codec: 'pcm' | 'opus' | 'aac';
    /** Encoding bit rate */
    bitRate: number;
    /** Variable bit rate enabled */
    variableBitRate: boolean;
    /** Complexity level for encoding */
    complexity?: number;
}
export interface ConnectionConfig {
    /** Base URL for the Realtime API */
    baseUrl?: string;
    /** WebSocket endpoint URL */
    websocketUrl?: string;
    /** Token endpoint URL for session authentication */
    tokenEndpoint?: string;
    /** Connection timeout in milliseconds */
    timeout: number;
    /** Maximum number of connection retries */
    maxRetries: number;
    /** Retry delay in milliseconds */
    retryDelay: number;
    /** Exponential backoff factor for retries */
    retryBackoffFactor: number;
    /** Keep-alive ping interval */
    pingInterval: number;
    /** Maximum time to wait for pong response */
    pongTimeout: number;
    /** Enable automatic reconnection */
    autoReconnect: boolean;
    /** Headers to include in connection requests */
    headers?: Record<string, string>;
}
export interface LoggerConfig {
    /** Logging level */
    level: LogLevel;
    /** Enable console logging */
    console: boolean;
    /** Enable file logging */
    file?: {
        enabled: boolean;
        path: string;
        maxSize: number;
        maxFiles: number;
    };
    /** Custom logger instance */
    customLogger?: Logger;
    /** Include timestamps in logs */
    includeTimestamp: boolean;
    /** Include stack traces for errors */
    includeStackTrace: boolean;
}
export type LogLevel = 'debug' | 'info' | 'warn' | 'error' | 'silent';
export interface Logger {
    debug(message: string, ...args: any[]): void;
    info(message: string, ...args: any[]): void;
    warn(message: string, ...args: any[]): void;
    error(message: string, ...args: any[]): void;
}
export interface MetricsConfig {
    /** Enable metrics collection */
    enabled: boolean;
    /** Metrics collection interval in milliseconds */
    interval: number;
    /** Maximum number of metric samples to keep */
    maxSamples: number;
    /** Custom metrics collector */
    customCollector?: MetricsCollector;
    /** Metrics to collect */
    collect: {
        /** Collect latency metrics */
        latency: boolean;
        /** Collect bandwidth metrics */
        bandwidth: boolean;
        /** Collect audio quality metrics */
        audioQuality: boolean;
        /** Collect connection stability metrics */
        connectionStability: boolean;
        /** Collect error metrics */
        errors: boolean;
    };
}
export interface MetricsCollector {
    collect(metric: Metric): void;
    getMetrics(): Metric[];
    clearMetrics(): void;
}
export interface Metric {
    name: string;
    value: number;
    timestamp: number;
    tags?: Record<string, string>;
}
export interface SessionLimitsConfig {
    /** Maximum session duration in milliseconds */
    maxSessionDuration?: number;
    /** Maximum messages per session */
    maxMessagesPerSession?: number;
    /** Maximum audio duration per message in seconds */
    maxAudioDurationPerMessage?: number;
    /** Maximum total audio duration per session in seconds */
    maxTotalAudioDuration?: number;
    /** Maximum text length per message */
    maxTextLengthPerMessage?: number;
    /** Idle timeout in milliseconds before disconnecting */
    idleTimeout?: number;
    /** Maximum concurrent sessions per user */
    maxConcurrentSessions?: number;
}
export interface SecurityConfig {
    /** Validate SSL certificates */
    validateCertificates: boolean;
    /** Allowed origins for CORS */
    allowedOrigins?: string[];
    /** API key validation */
    apiKeyValidation: {
        enabled: boolean;
        pattern?: RegExp;
    };
    /** Rate limiting configuration */
    rateLimiting?: {
        enabled: boolean;
        maxRequestsPerMinute: number;
        maxRequestsPerHour: number;
    };
}
export interface TelemetryConfig {
    /** Enable telemetry collection */
    enabled: boolean;
    /** Custom telemetry collector */
    customCollector?: TelemetryCollector;
    /** Telemetry event callbacks */
    callbacks?: {
        /** Called when session starts */
        onSessionStart?: (sessionId: string, metadata?: Record<string, any>) => void;
        /** Called when session ends */
        onSessionEnd?: (sessionId: string, duration: number, metadata?: Record<string, any>) => void;
        /** Called when message is sent */
        onMessageSent?: (messageType: 'text' | 'audio', metadata?: Record<string, any>) => void;
        /** Called when message is received */
        onMessageReceived?: (messageType: 'text' | 'audio', metadata?: Record<string, any>) => void;
        /** Called when error occurs */
        onError?: (error: Error, context?: Record<string, any>) => void;
        /** Called when connection state changes */
        onConnectionStateChange?: (state: string, metadata?: Record<string, any>) => void;
        /** Called for custom events */
        onCustomEvent?: (eventName: string, data?: any) => void;
    };
    /** Batching configuration for telemetry events */
    batching?: {
        enabled: boolean;
        batchSize: number;
        flushInterval: number;
    };
}
export interface TelemetryCollector {
    collect(event: TelemetryEvent): void;
    flush(): Promise<void>;
}
export interface TelemetryEvent {
    type: string;
    timestamp: number;
    sessionId?: string;
    data?: any;
    metadata?: Record<string, any>;
}
export interface RealtimeWebRTCConfig {
    /** Session configuration */
    session: SessionConfig;
    /** WebRTC configuration */
    webrtc: WebRTCConfig;
    /** Audio processing configuration */
    audio: AudioConfig;
    /** Connection configuration */
    connection: ConnectionConfig;
    /** Logger configuration */
    logger?: LoggerConfig;
    /** Metrics configuration */
    metrics?: MetricsConfig;
    /** Security configuration */
    security?: SecurityConfig;
    /** Session limits configuration */
    sessionLimits?: SessionLimitsConfig;
    /** Telemetry configuration */
    telemetry?: TelemetryConfig;
}
export interface ConfigValidationResult {
    /** Whether the configuration is valid */
    valid: boolean;
    /** Validation errors */
    errors: ConfigValidationError[];
    /** Configuration warnings */
    warnings: ConfigValidationWarning[];
}
export interface ConfigValidationError {
    /** Configuration path that failed validation */
    path: string;
    /** Error message */
    message: string;
    /** Expected value type */
    expected?: string;
    /** Actual value received */
    actual?: any;
}
export interface ConfigValidationWarning {
    /** Configuration path */
    path: string;
    /** Warning message */
    message: string;
    /** Suggested value */
    suggestion?: any;
}
export declare const DEFAULT_SESSION_CONFIG: Partial<SessionConfig>;
export declare const DEFAULT_WEBRTC_CONFIG: WebRTCConfig;
export declare const DEFAULT_AUDIO_CONFIG: AudioConfig;
export declare const DEFAULT_CONNECTION_CONFIG: ConnectionConfig;
export declare const DEFAULT_LOGGER_CONFIG: LoggerConfig;
export declare const DEFAULT_METRICS_CONFIG: MetricsConfig;
export declare const DEFAULT_SECURITY_CONFIG: SecurityConfig;
export declare const DEFAULT_SESSION_LIMITS_CONFIG: SessionLimitsConfig;
export declare const DEFAULT_TELEMETRY_CONFIG: TelemetryConfig;
export declare class ConfigBuilder {
    private config;
    session(config: Partial<SessionConfig>): this;
    webrtc(config: Partial<WebRTCConfig>): this;
    audio(config: Partial<AudioConfig>): this;
    connection(config: Partial<ConnectionConfig>): this;
    logger(config: Partial<LoggerConfig>): this;
    metrics(config: Partial<MetricsConfig>): this;
    security(config: Partial<SecurityConfig>): this;
    sessionLimits(config: Partial<SessionLimitsConfig>): this;
    telemetry(config: Partial<TelemetryConfig>): this;
    build(): RealtimeWebRTCConfig;
}
//# sourceMappingURL=config.d.ts.map