<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Visualization - OpenAI Realtime WebRTC</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: white;
            min-height: 100vh;
            overflow: hidden;
        }

        .background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #000 100%);
            z-index: -1;
        }

        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
            position: relative;
            z-index: 10;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            font-size: 48px;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #00ff88, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient 3s ease infinite;
            background-size: 200% 200%;
        }

        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .subtitle {
            color: #888;
            font-size: 18px;
        }

        .visualizer-container {
            position: relative;
            height: 400px;
            margin-bottom: 40px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }

        #waveformCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #spectrumCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.7;
            mix-blend-mode: screen;
        }

        .controls-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-panel h3 {
            color: #00ff88;
            margin-bottom: 20px;
            font-size: 20px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            color: #aaa;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #00ff88;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .control-group input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 10px #00ff88;
        }

        .control-value {
            color: #00ffff;
            font-weight: 600;
            float: right;
        }

        .visualization-modes {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .mode-btn {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .mode-btn.active {
            background: #00ff88;
            color: black;
            border-color: #00ff88;
        }

        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 40px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-value {
            font-size: 32px;
            font-weight: 700;
            color: #00ffff;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #888;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .connection-controls {
            text-align: center;
            margin-bottom: 40px;
        }

        .api-key-input {
            width: 100%;
            max-width: 400px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: white;
            font-size: 16px;
            margin-bottom: 20px;
        }

        .api-key-input:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .button-group {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 30px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .connect-btn {
            background: linear-gradient(45deg, #00ff88, #00ffff);
            color: black;
        }

        .connect-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.4);
        }

        .disconnect-btn {
            background: #ff0066;
            color: white;
        }

        .disconnect-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(255, 0, 102, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .error {
            background: rgba(255, 0, 102, 0.2);
            border: 1px solid #ff0066;
            color: #ff6699;
            padding: 15px;
            border-radius: 10px;
            margin: 20px auto;
            max-width: 600px;
            text-align: center;
        }

        .level-meter {
            position: relative;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 10px;
        }

        .level-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ffff, #ff00ff);
            border-radius: 5px;
            transition: width 0.1s ease;
            box-shadow: 0 0 10px currentColor;
        }

        .frequency-display {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="background"></div>
    <canvas class="particles" id="particles"></canvas>

    <div class="container">
        <div class="header">
            <h1>Audio Visualization Studio</h1>
            <p class="subtitle">Real-time voice visualization with OpenAI</p>
        </div>

        <div class="connection-controls">
            <input 
                type="password" 
                class="api-key-input" 
                id="apiKey" 
                placeholder="Enter your OpenAI API key"
            />
            <div class="button-group">
                <button class="connect-btn" id="connectBtn">Connect</button>
                <button class="disconnect-btn" id="disconnectBtn" disabled>Disconnect</button>
            </div>
            <div class="error" id="error" style="display: none;"></div>
        </div>

        <div class="stats-container">
            <div class="stat-card">
                <div class="stat-value" id="volumeStat">0</div>
                <div class="stat-label">Volume</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="frequencyStat">0</div>
                <div class="stat-label">Peak Hz</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="activeStat">--</div>
                <div class="stat-label">Activity</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="timeStat">0:00</div>
                <div class="stat-label">Duration</div>
            </div>
        </div>

        <div class="visualizer-container">
            <canvas id="waveformCanvas"></canvas>
            <canvas id="spectrumCanvas"></canvas>
        </div>

        <div class="controls-container">
            <div class="control-panel">
                <h3>Visualization Settings</h3>
                <div class="control-group">
                    <label>Mode</label>
                    <div class="visualization-modes">
                        <button class="mode-btn active" data-mode="waveform">Waveform</button>
                        <button class="mode-btn" data-mode="spectrum">Spectrum</button>
                        <button class="mode-btn" data-mode="circular">Circular</button>
                        <button class="mode-btn" data-mode="bars">Bars</button>
                    </div>
                </div>
                <div class="control-group">
                    <label>
                        Sensitivity
                        <span class="control-value" id="sensitivityValue">50</span>
                    </label>
                    <input type="range" id="sensitivity" min="1" max="100" value="50">
                </div>
                <div class="control-group">
                    <label>
                        Smoothing
                        <span class="control-value" id="smoothingValue">0.8</span>
                    </label>
                    <input type="range" id="smoothing" min="0" max="1" step="0.1" value="0.8">
                </div>
            </div>

            <div class="control-panel">
                <h3>Color Settings</h3>
                <div class="control-group">
                    <label>Color Mode</label>
                    <div class="visualization-modes">
                        <button class="mode-btn active" data-color="rainbow">Rainbow</button>
                        <button class="mode-btn" data-color="monochrome">Mono</button>
                        <button class="mode-btn" data-color="reactive">Reactive</button>
                    </div>
                </div>
                <div class="control-group">
                    <label>
                        Brightness
                        <span class="control-value" id="brightnessValue">100</span>
                    </label>
                    <input type="range" id="brightness" min="0" max="100" value="100">
                </div>
                <div class="control-group">
                    <label>Audio Level</label>
                    <div class="level-meter">
                        <div class="level-fill" id="levelFill"></div>
                    </div>
                    <div class="frequency-display">
                        <span>20Hz</span>
                        <span>1kHz</span>
                        <span>5kHz</span>
                        <span>10kHz</span>
                        <span>20kHz</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Mock AudioVisualizer for demonstration
        class MockAudioVisualizer {
            constructor(config) {
                this.config = config;
                this.handlers = {};
                this.isConnected = false;
                this.audioData = new Float32Array(256);
                this.frequencyData = new Uint8Array(256);
            }
            
            on(event, handler) {
                this.handlers[event] = handler;
            }
            
            async connect() {
                setTimeout(() => {
                    this.isConnected = true;
                    if (this.handlers.connected) {
                        this.handlers.connected();
                    }
                    this.startSimulation();
                }, 1000);
            }
            
            async disconnect() {
                this.isConnected = false;
                if (this.handlers.disconnected) {
                    this.handlers.disconnected();
                }
            }
            
            startSimulation() {
                const animate = () => {
                    if (!this.isConnected) return;
                    
                    // Simulate audio data
                    const time = Date.now() / 1000;
                    for (let i = 0; i < this.audioData.length; i++) {
                        this.audioData[i] = Math.sin(i * 0.1 + time) * 0.5 + 
                                          Math.sin(i * 0.05 + time * 2) * 0.3 +
                                          (Math.random() - 0.5) * 0.2;
                    }
                    
                    // Simulate frequency data
                    for (let i = 0; i < this.frequencyData.length; i++) {
                        this.frequencyData[i] = Math.abs(this.audioData[i]) * 255 * 
                                               (1 - i / this.frequencyData.length) +
                                               Math.random() * 30;
                    }
                    
                    // Calculate audio level
                    const level = this.audioData.reduce((sum, val) => sum + Math.abs(val), 0) / this.audioData.length;
                    
                    if (this.handlers.audioData) {
                        this.handlers.audioData({
                            waveform: this.audioData,
                            frequency: this.frequencyData,
                            level: level,
                            peakFrequency: Math.random() * 5000 + 200
                        });
                    }
                    
                    requestAnimationFrame(animate);
                };
                animate();
            }
        }
        
        // Initialize variables
        let visualizer = null;
        let isConnected = false;
        let startTime = null;
        let visualizationMode = 'waveform';
        let colorMode = 'rainbow';
        
        // Get DOM elements
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const error = document.getElementById('error');
        const apiKeyInput = document.getElementById('apiKey');
        const waveformCanvas = document.getElementById('waveformCanvas');
        const spectrumCanvas = document.getElementById('spectrumCanvas');
        const particlesCanvas = document.getElementById('particles');
        
        // Stats elements
        const volumeStat = document.getElementById('volumeStat');
        const frequencyStat = document.getElementById('frequencyStat');
        const activeStat = document.getElementById('activeStat');
        const timeStat = document.getElementById('timeStat');
        const levelFill = document.getElementById('levelFill');
        
        // Control elements
        const sensitivity = document.getElementById('sensitivity');
        const smoothing = document.getElementById('smoothing');
        const brightness = document.getElementById('brightness');
        
        // Canvas contexts
        const waveCtx = waveformCanvas.getContext('2d');
        const spectrumCtx = spectrumCanvas.getContext('2d');
        const particlesCtx = particlesCanvas.getContext('2d');
        
        // Resize canvases
        function resizeCanvases() {
            const container = document.querySelector('.visualizer-container');
            const rect = container.getBoundingClientRect();
            
            waveformCanvas.width = rect.width;
            waveformCanvas.height = rect.height;
            spectrumCanvas.width = rect.width;
            spectrumCanvas.height = rect.height;
            
            particlesCanvas.width = window.innerWidth;
            particlesCanvas.height = window.innerHeight;
        }
        
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);
        
        // Visualization functions
        function drawWaveform(data, ctx) {
            const width = ctx.canvas.width;
            const height = ctx.canvas.height;
            const bufferLength = data.length;
            
            ctx.clearRect(0, 0, width, height);
            ctx.lineWidth = 2;
            ctx.strokeStyle = getColor(0.5);
            
            ctx.beginPath();
            const sliceWidth = width / bufferLength;
            let x = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                const v = data[i] * sensitivity.value / 50;
                const y = (v + 1) / 2 * height;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                
                x += sliceWidth;
            }
            
            ctx.lineTo(width, height / 2);
            ctx.stroke();
        }
        
        function drawSpectrum(data, ctx) {
            const width = ctx.canvas.width;
            const height = ctx.canvas.height;
            const bufferLength = data.length;
            
            ctx.clearRect(0, 0, width, height);
            
            const barWidth = (width / bufferLength) * 2.5;
            let x = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                const barHeight = (data[i] / 255) * height * sensitivity.value / 50;
                
                ctx.fillStyle = getColor(i / bufferLength);
                ctx.fillRect(x, height - barHeight, barWidth, barHeight);
                
                x += barWidth + 1;
            }
        }
        
        function drawCircular(data, ctx) {
            const width = ctx.canvas.width;
            const height = ctx.canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 3;
            
            ctx.clearRect(0, 0, width, height);
            ctx.save();
            ctx.translate(centerX, centerY);
            
            const bufferLength = data.length;
            const angleStep = (Math.PI * 2) / bufferLength;
            
            ctx.beginPath();
            for (let i = 0; i < bufferLength; i++) {
                const angle = i * angleStep;
                const amp = 1 + (data[i] / 255) * sensitivity.value / 50;
                const x = Math.cos(angle) * radius * amp;
                const y = Math.sin(angle) * radius * amp;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.closePath();
            ctx.strokeStyle = getColor(0.5);
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
        }
        
        function drawBars(data, ctx) {
            const width = ctx.canvas.width;
            const height = ctx.canvas.height;
            const bufferLength = data.length / 4; // Use less bars for cleaner look
            
            ctx.clearRect(0, 0, width, height);
            
            const barWidth = width / bufferLength - 5;
            let x = 2.5;
            
            for (let i = 0; i < bufferLength; i++) {
                const barHeight = (data[i * 4] / 255) * height * sensitivity.value / 50;
                
                // Draw gradient bar
                const gradient = ctx.createLinearGradient(0, height - barHeight, 0, height);
                gradient.addColorStop(0, getColor(i / bufferLength));
                gradient.addColorStop(1, getColor((i / bufferLength) + 0.1));
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x, height - barHeight, barWidth, barHeight);
                
                // Draw reflection
                ctx.globalAlpha = 0.3;
                ctx.fillRect(x, height, barWidth, barHeight * 0.3);
                ctx.globalAlpha = 1;
                
                x += barWidth + 5;
            }
        }
        
        function getColor(position) {
            const brightnessValue = brightness.value / 100;
            
            if (colorMode === 'rainbow') {
                const hue = position * 360;
                return `hsla(${hue}, 100%, ${50 * brightnessValue}%, 0.8)`;
            } else if (colorMode === 'monochrome') {
                return `rgba(0, 255, 136, ${0.8 * brightnessValue})`;
            } else { // reactive
                const hue = 180 + position * 180;
                return `hsla(${hue}, 100%, ${50 * brightnessValue}%, 0.8)`;
            }
        }
        
        // Background particles
        function drawParticles() {
            particlesCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            particlesCtx.fillRect(0, 0, particlesCanvas.width, particlesCanvas.height);
            
            // Draw random particles
            for (let i = 0; i < 3; i++) {
                particlesCtx.beginPath();
                particlesCtx.arc(
                    Math.random() * particlesCanvas.width,
                    Math.random() * particlesCanvas.height,
                    Math.random() * 2,
                    0,
                    Math.PI * 2
                );
                particlesCtx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.5})`;
                particlesCtx.fill();
            }
            
            requestAnimationFrame(drawParticles);
        }
        drawParticles();
        
        // Update timer
        function updateTimer() {
            if (isConnected && startTime) {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                timeStat.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
            requestAnimationFrame(updateTimer);
        }
        updateTimer();
        
        // Show error
        function showError(message) {
            error.textContent = message;
            error.style.display = 'block';
            setTimeout(() => {
                error.style.display = 'none';
            }, 5000);
        }
        
        // Connect
        async function connect() {
            const apiKey = apiKeyInput.value.trim();
            
            if (!apiKey) {
                showError('Please enter your OpenAI API key');
                return;
            }
            
            try {
                visualizer = new MockAudioVisualizer({
                    apiKey: apiKey,
                    model: 'gpt-4o-realtime-preview-2024-12-17'
                });
                
                visualizer.on('connected', () => {
                    isConnected = true;
                    startTime = Date.now();
                    connectBtn.disabled = true;
                    disconnectBtn.disabled = false;
                    activeStat.textContent = 'Active';
                });
                
                visualizer.on('disconnected', () => {
                    isConnected = false;
                    connectBtn.disabled = false;
                    disconnectBtn.disabled = true;
                    activeStat.textContent = '--';
                });
                
                visualizer.on('audioData', (data) => {
                    // Update visualizations
                    if (visualizationMode === 'waveform') {
                        drawWaveform(data.waveform, waveCtx);
                    } else if (visualizationMode === 'spectrum') {
                        drawSpectrum(data.frequency, spectrumCtx);
                    } else if (visualizationMode === 'circular') {
                        drawCircular(data.frequency, waveCtx);
                    } else if (visualizationMode === 'bars') {
                        drawBars(data.frequency, waveCtx);
                    }
                    
                    // Update stats
                    const volume = Math.round(data.level * 100);
                    volumeStat.textContent = volume;
                    frequencyStat.textContent = Math.round(data.peakFrequency);
                    levelFill.style.width = `${Math.min(100, volume)}%`;
                });
                
                await visualizer.connect();
                
            } catch (err) {
                showError(`Failed to connect: ${err.message}`);
            }
        }
        
        // Disconnect
        async function disconnect() {
            if (visualizer) {
                await visualizer.disconnect();
                visualizer = null;
            }
            
            // Clear canvases
            waveCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
            spectrumCtx.clearRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);
            
            // Reset stats
            volumeStat.textContent = '0';
            frequencyStat.textContent = '0';
            timeStat.textContent = '0:00';
            levelFill.style.width = '0%';
        }
        
        // Event listeners
        connectBtn.addEventListener('click', connect);
        disconnectBtn.addEventListener('click', disconnect);
        
        // Mode buttons
        document.querySelectorAll('[data-mode]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-mode]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                visualizationMode = btn.dataset.mode;
                
                // Clear canvases when switching modes
                waveCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
                spectrumCtx.clearRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);
            });
        });
        
        // Color mode buttons
        document.querySelectorAll('[data-color]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-color]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                colorMode = btn.dataset.color;
            });
        });
        
        // Control updates
        sensitivity.addEventListener('input', (e) => {
            document.getElementById('sensitivityValue').textContent = e.target.value;
        });
        
        smoothing.addEventListener('input', (e) => {
            document.getElementById('smoothingValue').textContent = e.target.value;
        });
        
        brightness.addEventListener('input', (e) => {
            document.getElementById('brightnessValue').textContent = e.target.value;
        });
        
        // Enter to connect
        apiKeyInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !isConnected) {
                connect();
            }
        });
    </script>
</body>
</html>